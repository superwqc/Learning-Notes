一.内存对齐
  1.什么是内存对齐
  假设我们同时声明两个变量：
  char a;
  short b;
  用&（取地址符号）观察变量a，b的地址的话，我们会发现（以16位CPU为例）：
  如果a的地址是0x0000，那么b的地址将会是0x0002或者是0x0004。
  那么就出现这样一个问题：0x0001这个地址没有被使用，那它干什么去了？ 答案就是它确实没被使用。 
  因为CPU每次都是从以2字节（16位CPU）或是4字节（32位CPU）的整数倍的内存地址中读进数据的。
  如果变量b的地址是0x0001的话，那么CPU就需要先从0x0000中读取一个short，取它的高8位放入b的低8位，
  然后再从0x0002中读取下一个short，取它的低8位放入b的高8位中，这样的话，为了获得b的值，CPU需要进行了两次读操作。
 
  但是如果b的地址为0x0002，
  那么CPU只需一次读操作就可以获得b的值了。所以编译器为了优化代码，往往会根据变量的大小，将其指定到合适的位置，即称为内存对齐
  （对变量b做内存对齐，a、b之间的内存被浪费，a并未多占内存）。
  
  
2.结构体内存对齐规则（请记住三条内存规则(在没有#pragam pack宏的情况下）
    结构体所占用的内存与其成员在结构体中的声明顺序有关，其成员的内存对齐规则如下：
  （1）每个成员分别按自己的对齐字节数和PPB（指定的对齐字节数，32位机默认为4）两个字节数最小的那个对齐，这样可以最小化长度。如在32bit的机器上，int的大小为4，因此int存储的位置都是4的整数倍的位置开始存储。
  （2）复杂类型(如结构)的默认对齐方式是它最长的成员的对齐方式，这样在成员是复杂类型时，结构体数组的时候，可以最小化长度。
  （3）结构体对齐后的长度必须是成员中最大的对齐参数（PPB）的整数倍，这样在处理数组时可以保证每一项都边界对齐。
  （4）结构体作为数据成员的对齐规则：在一个struct中包含另一个struct，内部struct应该以它的最大数据成员大小的整数倍开始存储。
       如 struct A 中包含 struct B, struct B 中包含数据成员 char, int, double，则 struct B 应该以sizeof(double)=8的整数倍为起始地址。

3.实例演示：
struct A
{
char a;　　　//内存位置:  [0]
double b;　  // 内存位置: [8]...[15]
int c;　　　　// 内存位置: [16]...[19]　　----　　规则1
};　　　　　　　 // 内存大小：sizeof(A) = (1+7) + 8 + (4+4) = 24, 补齐[20]...[23]　　----　　规则3
 
struct B
{
int a,　　　　// 内存位置: [0]...[3]
A b,　    　　// 内存位置: [8]...[31]　　----　　规则2
char c,　　　// 内存位置: [32]
};　　　　　　　  // 内存大小：sizeof(B) = (4+4) + 24 + (1+7) = 40, 补齐[33]...[39]
*注释：(1+7)表示该数据成员大小为1，补齐7位；(4+4)同理。
